/* Copyright 2023 Better Ltd (www.better.care)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package care.better.pf4j.ksp.processor

import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSDeclaration
import com.google.devtools.ksp.symbol.KSType
import com.google.devtools.ksp.validate
import org.pf4j.Extension
import org.pf4j.ExtensionPoint
import kotlin.reflect.KClass

/**
 * @author Primoz Delopst
 * @since 1.0.0
 *
 * Implementation of the [SymbolProcessor] that process [Extension] annotation.
 *
 * @constructor Creates a new instance of [ExtensionSymbolProcessor]
 * @param environment [SymbolProcessorEnvironment]
 */
class ExtensionSymbolProcessor(private val environment: SymbolProcessorEnvironment) : SymbolProcessor {

    companion object {
        private const val EXTENSION_CLASS_NAME: String = "org.pf4j.Extension"
        private const val EXTENSION_POINT_CLASS_NAME: String = "org.pf4j.ExtensionPoint"
        private const val USE_JSP: String = "pf4j.useJavaServiceProviders"
        private const val IGNORE_EXTENSION_POINT: String = "pf4j.ignoreExtensionPoint"
        private const val EXTENSION_POINTS_ATTRIBUTE: String = "points"
        private const val EXTENSION_FILE_PATH: String = "META-INF/extensions"
        private const val EXTENSION_FILE_EXTENSION: String = "idx"
        private const val GENERATED_BY_PF4J: String = "#Generated by PF4J"
        private const val NEW_LINE: String = "\n"
        private const val BLANK_STRING: String = ""
    }

    private val ignoreExtensionPoint: Boolean =
        environment.options[IGNORE_EXTENSION_POINT]?.toBoolean() ?: System.getProperty("pf4j.ignoreExtensionPoint", "false").toBoolean()

    private val useJavaServiceProviders =
        environment.options[USE_JSP]?.toBoolean() ?: System.getProperty("pf4j.useJavaServiceProviders", "false").toBoolean()

    /**
     * Finalize the processing of a [Extension] annotation processing.
     */
    override fun finish() {
        environment.logger.info("Processing of org.pf4j.Extension annotations finished successfully.")
    }

    /**
     * Handle errors of the [Extension] annotation processing.
     */
    override fun onError() {
        environment.logger.info("Error occurred while processing org.pf4j.Extension annotations.")
    }

    /**
     * Processes the [Extension] annotations.
     *
     * @param resolver [Resolver]
     * @return [List] of [KSAnnotated]
     */
    override fun process(resolver: Resolver): List<KSAnnotated> {
        val classDeclarations: List<KSClassDeclaration> = resolver.getSymbolsWithAnnotation(Extension::class)

        if (classDeclarations.isEmpty()) {
            return emptyList()
        }

        if (useJavaServiceProviders) {
            classDeclarations.map { classDeclaration -> classDeclaration.toClassName() }.distinct().forEach { className ->
                val file = environment.codeGenerator.createNewFileByPath(
                        Dependencies(false),
                        className,
                        BLANK_STRING)

                file.write(
                        "$GENERATED_BY_PF4J$NEW_LINE${className}".toByteArray())
            }
        } else {
            val file = environment.codeGenerator.createNewFileByPath(
                    Dependencies(false),
                    EXTENSION_FILE_PATH,
                    EXTENSION_FILE_EXTENSION)

            file.write(
                    "$GENERATED_BY_PF4J$NEW_LINE${
                        classDeclarations.map { classDeclaration -> classDeclaration.toClassName() }.distinct().joinToString(NEW_LINE)
                    }".toByteArray())
        }
        return (classDeclarations).filterNot { it.validate() }.toList()
    }

    /**
     * Returns [List] of [KSClassDeclaration] for [KClass].
     *
     * @param kClass [KClass]
     * @return [List] of [KSClassDeclaration]
     */
    private fun Resolver.getSymbolsWithAnnotation(kClass: KClass<*>): List<KSClassDeclaration> =
        getSymbolsWithAnnotation(kClass.qualifiedName.toString())
            .filterIsInstance<KSClassDeclaration>()
            .resolveExtensionPoints()
            .distinct()
            .toList()

    /**
     * Resolves and returns [Sequence] of [KSClassDeclaration] that implements [ExtensionPoint].
     *
     * @return [Sequence] of [KSClassDeclaration]
     */
    private fun Sequence<KSClassDeclaration>.resolveExtensionPoints(): Sequence<KSClassDeclaration> =
        flatMap { classDeclaration ->
            val points = classDeclaration.annotations
                .filter { it.annotationType.resolve().declaration.qualifiedName?.asString() == EXTENSION_CLASS_NAME }
                .flatMap { it.arguments.asSequence() }
                .filter { it.name?.asString() == EXTENSION_POINTS_ATTRIBUTE }
                .flatMap { if (it.value is List<*>) (it.value as List<*>).asSequence().filterNotNull() else sequenceOf(it.value).filterNotNull() }
                .filterIsInstance<KSType>()
                .map { it.declaration }
                .filterIsInstance<KSClassDeclaration>()
                .toList()

            when {
                points.isNotEmpty() -> points.asSequence()
                classDeclaration.isImplementingExtensionPoint() -> sequenceOf(classDeclaration)
                else ->
                    if (ignoreExtensionPoint)
                        emptySequence()
                    else
                        throw ExtensionSymbolProcessorException("${classDeclaration.toClassName()} does not implement $EXTENSION_POINT_CLASS_NAME interface.")
            }
        }

    /**
     * Checks if [KSClassDeclaration] implements [ExtensionPoint].
     *
     * @return [Boolean] indicating if [KSClassDeclaration] implements [ExtensionPoint]
     */
    private fun KSClassDeclaration.isImplementingExtensionPoint(): Boolean =
        superTypes.any { superType ->
            val declaration = superType.resolve().declaration
            when {
                declaration.qualifiedName?.asString() == EXTENSION_POINT_CLASS_NAME -> true
                declaration is KSClassDeclaration -> declaration.isImplementingExtensionPoint()
                else -> false
            }
        }

    /**
     * Returns [KSClassDeclaration] declared class name of the processed class.
     *
     * @return [KSClassDeclaration] declared class name
     */
    private fun KSClassDeclaration.toClassName(): String =
        "${packageName.asString()}.${parentDeclaration.toClassName()}${simpleName.asString()}"

    /**
     * Returns [KSDeclaration] declared class name of the processed.
     * Note that [KSDeclaration] is used for outer class.
     *
     * @return [KSDeclaration] declared class name
     */
    private fun KSDeclaration?.toClassName(): String =
        when {
            this == null -> BLANK_STRING
            parentDeclaration != null -> "${simpleName.asString()}$${(parentDeclaration.toClassName())}"
            else -> "${simpleName.asString()}$"
        }
}